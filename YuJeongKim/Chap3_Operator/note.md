## 연산자의 결합규칙

1. 산술 > 비교 > 논리 > 대입. 대입은 제일 마지막에 수행된다.
2. 단항(1) > 이항(2) > 삼항(3). 단항 연산자의 우선순위가 이상 연산자보다 높다.
3. 단항 연산자와 대입 연산자를 제외한 모든 연산의 진행방향은 왼쪽에서 오른쪽이다.

## 산술 변환

이항 연산자는 두 피연산자의 타입이 일치해야 연산이 가능하다.

```jsx
int i = 10;
float f = 20.0f;

float result = f+i; //큰 타입으로 형변환시, 형변환연산자 생략가능
```

1. 두 피연산자의 타입을 같에 일치시킨다. (보다 큰 타입으로 일치)
2. 피연산자의 타입이 int보다 작은 타입이면 int로 변환된다.

## 단항 연산자

++i 와 i++ 처럼 증감연산자가 수식이나 메서드 호출에 포함되지 않고 독립적인 하나의 문장으로 쓰인 경우에는 전위형과 후외형의 차이가 없다.

```jsx
int i=5;
i++;
System.out.println(i);

i=5;
++i;
System.out.println(i);
```

실행결과 둘 다 6이 출력된다. 단독적으로 사용된 것이기 때문에!

```jsx
int i=5, j=0;
j = i++;
System.ot.println("j=i++; 실행 후, i=" + i + ", j=" + j);

i=5;
j=0;

j = ++i;
System.out.println("j=++i; 실행 후, i=" + i +", j=" + j);
```

j=i++; 실행 후, i=6, j=5

j=++i; 실행 후, i=6, j=6

전위형은 변수(피연산자)의 값을 먼저 증가시킨 후에 변수의 값을 읽어오는 반면, 후위형은 변수의 값을 먼저 읽어온 후에 값을 증가시킨다.

## 산술 연산자

1)

```jsx
byte a = 10;
byte b = 20;
byte c = a + b; //컴파일 에러! 명시적으로 형변환이 필요하다.
System.out.println(c);
```

a와 b는 모두 int형보다 작은 byte형이기 때문에 연산자 + 는 두 개의 피연산자들의 자료형을 int형으로 변환한 다음 덧셈을 수행한다. 

그래서 a+b의 연산결과는 byte형이 아닌 int형(4byte)인 것이다. 4byte의 값을 1byte의 변수에 형변환없이 저장하려 했기 때문에 에러가 발생한다.

2)

```jsx
byte a = 10;
byte b = 30;
byte c = (byte)a * b; 
System.out.println(c);
```

이 예제를 실행하면 44가 출력된다. 10*30의 결과는 300이지만, 큰 자료형에서 작은 자료형으로 변환하면 데이터의 손실이 발생하므로 값이 바뀔 수 있다. 

300은 byte형의 범위를 넘기 때문에 byte형으로 변환하면 데이터 손실이 발행하여 결국 44가 byte형 변수 c에 저장된다. 

앞의 24자리를 없애고 하위 8자리(1byte)만을 보존한다. 

3)

```jsx
long a = 1_000_000 * 1_000_000;
long b = 1_000_000 * 1_000_000L;

System.out.println(a);
System.out.println(b);
```

실행결과는 다음과 같다. a = -727379968 , b = 1000000000000

1_000_000 * 1_000_000의 결과가 10의12승임에도 불구하고 -727379968이 출력되었다. 그 이유는 int 타입과 int타입의 연산결과는 int타입인데, 연산결과가 int타입의 최대값인 약 2*10의9승 을 넘으므로 오버플로우가 발생했기 때문이다. 이미 오버플로우가 발생한 값을 long타입의 변수에 저장을 해도 소용이 없다.

4)

사칙연산의 피연산자로 숫자뿐만 아니라 문자도 가능하다.

문자는 실제로 해당 문자의 유니코드(부호 없는 정수)로 바뀌어 저장되므로 문자간의 사칙연산은 정수간의 연산과 동일하다. 

5)

```jsx
char c1 = 'a';
//char c2 = c1+1; //컴파일 에러 발생!!
char c2 = 'a'+1;

System.out.println(c2);
```

덧셈 연산자와 같은 이항 연산자는 int보다 작은 타입의 피연산자를 int로 자동 형변환한다 배웠는데, 형변환을 해주지 않아도 문제가 없을까?

'a'+1은 리터럴 간의 연산이기 때문이다. 상수 또는 리터럴 간의 연산은 실행과정동안 변하는 값이 아니기 때문에, 컴파일 시에 컴파일러가 계산해서 그 결과로 대체한다.

컴파일러가 미리 덧셈연산을 수행하기 때문에 실행 시에는 덧셈 연산이 수행되지 않는다. 그저 덧셈연산 결과인 문자 ‘b’를 변수 c2에 저장할 뿐이다. 

그러나 수식에 변수가 들어가 있는 경우에는 컴파일러가 미리 계산을 할 수 없기 때문에 형변환을 해주어야 한다. 

char c2 = c1+1;   →  char c2 = (char)(c1+1);

## 나머지 연산자

나눗셈에서처럼 나누는 수(오른쪽 피연산자)로 0을 사용할 수 없다.

## 비교 연산자

비교 연산자 역시 이항 연산자이므로 비교하는 피연산자의 타입이 서로 다를 경우에는 자료형의 범위가 큰 쪽으로 자동 형변환하여 피연산자의 타입을 일치시킨 후에 비교한다.

## 문자열의 비교

문자열의 내용이 같은지 비교하기 위해서는 equals()를 사용한다. 같으면 true, 다르면 false를 반환한다.

## 논리연산자의 효율적인 연산

or연산 ’||’ 의 경우, 두 연산자 중 어느 쪽감 참이어도 전체 결과가 참이므로 좌측 피연산자가 참이면 우측 피연산자의 값은 평가하지 않는다. 

그래서 같은 조건식이라도 피연산자의 위치에 따라서 연산속도가 빨라질 수 있다.

## 비트 연산자 & | ^ ~ << >>

비트 연산자는 피연산자를 비트단위로 논리 연산한다. 피연산자를 2진수로 변환하여 연산을 수행하며, 피연산자로 정수(문자 포함)만 허용된다.

## 비트 전환 연산자 ~

피연산자를 2진수로 표현했을 때, 0은 1로, 1은 0으로 바꾼다. 즉, 피연산자의 ‘1의 보수’를 얻을 수 있다. 

비트 전환 연산자는 피연산자의 타입이 int보다 작으면 int로 자동 형변환(산술 변환) 후에 연산하기 때문에 연산결과는 32자리 2진수이다. 

따라서, 양의 정수 p가 있을 때, p에 대한 음의 정수를 얻으려면 ‘~p+1’을 계산하면 된다. 

## 쉬프트 연산자 << >>

피연산자의 각 자리(2진수로 표현했을 때)를 오른쪽(>>) 또는 왼쪽(<<)으로 이동한다.

>> 연산자는 오른쪽으로 이동시키기 때문에 부호있는 정수는 부호를 유지하기 위해 왼쪽 피연산자가 음수인 경우 빈자리를 1로 채운다. 

2진수 n자리를 왼쪽으로 이동하면 피연산자를 2^n으로 곱한 결과를, 오른쪽으로 이동하면 피연산자를 2^n으로 나눈 결과를 얻는다. 

예를 들어 10진수 123을 왼쪽으로 2자리 이동하면 12300가 되는데, 이 값은 123에 10^2을 곱한 결과다. 이 값을 다시 오른쪽으로 2자리 이동하면 123이 되고 이 값은 12300을 10^2으로 나눈 결과가 된다. 

단디 2진수이기 때문에 자리 이동시 2^n으로 곱하거나 나눈 결과를 얻는 것뿐이다. 

## 조건 연산자 ? :

<aside>
💡 조건식 ? 식1 : 식2

</aside>

삼항 연산자이다. 조건식의 결과가 true면 식1, false면 식2가 연산결과가 된다. 

조건 연산자의 식1과 식2, 이 두 피연산자의 타입이 다른 경우, 이항 연산자처럼 산술 변환이 발생한다.
