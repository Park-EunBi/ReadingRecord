# 1. 상속

## 1.1 상속의 정의와 장점

실생활에서의 부모님이 자녀에게 유산이나 재산을 상속하는 것처럼, 기존의 클래스(부모클래스)를 재사용하여 새로운 클래스(자식 클래스)를 작성하는 것이다.

### 상속의 장점

- 보다 적은 양의 코드로 새로운 클래스 작성가능
- 코드를 공통적으로 관리 가능.
- 코드의 추가 및 변경 용이

→ 코드 재사용성 ⬆️, 코드 중복 ⛔️ ⇒ 프로그램 생산성 & 유지보수 👾

### 자바에서의 상속 구현

- 새로 작성하는 클래스 이름 뒤에 상속받는 클래스 이름을 `extends` 키워드와 함께 작성.

예시1

- 새로 작성하려는 클래스 이름 : `Child`, 상속받고자 하는 기존 클래스 이름: `Parent`
    
    ```java
    class Child extends Parent{
    	// ...
    }
    ```
    
- 두 클래스는 서로 `상속 관계`, 상속해주는 클래스: `조상 클래스`, 상속 받는 클래스: `자손 클래스`
- 상속 관계에 있는 두 클래스를 그림으로 표현
    - **상속계층도(class hierarchy)**
    
    ![스크린샷 2023-02-13 오후 4.15.55.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/1311068c-51c8-44ed-9438-955c209b9baa/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2023-02-13_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_4.15.55.png)
    
    - 프로그램이 커질수록 클래스 관계가 복잡한데, 이는 위 그림과 같이 그림으로 표현하면 클래스간 관계를 보다 쉽게 이해할 수 있음.
    - 자손 클래스는 조상 클래스의 모든 멤버를 상속 받음(Child 클래스는 Parent 클래스의 멤버들을 포함)
    
- Parent 클래스에 age 정수형 변수 추가 → Child 클래스는 자동적으로 age 멤버 변수 추가됨.
- Child 클래스에 새로운 멤버로 play() 메서드 추가 → Parent 클래스에 아무런 영향 ❌
- 자손 클래스는 조상 클래스의 모든 멤버를 상속 받음 → 항상 조상 클래스보다 같거나 많은 멤버를 가짐.
- 상속에 상속을 거듭할 수록 상속받는 클래스의 멤버 변수 개수는 점점 늘어남.
- 상속을 받는다는 건, 조상 클래스를 확장(extend)한다는 의믜로 해석 가능.
    - 상속에 사용되는 키워드 : `extends` 인 이유.

예시2

- Parent 클래스로부터 상속받는 Child2 클래스.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/4e09a076-94eb-478c-aa51-b3de51f54706/Untitled.png)

- 동일한 부모 클래스인 Parent를 상속했지만 Child와 Child2는 아무런 관계도 성립 ❌
- 형제 관계 ❌ 상속 관계만 있을 뿐.
- if. Child 클래스와 Child2 클래스에 공통적으로 추가되어야 하는 멤버(변수, 메서드)가 있다면, 이 두 클래스에 각각 따로 추가해주는 것보다는 이들의 공통조상인 Parent에 추가하는 것이 좋음.
    - 같은 내용의 코드를 한 곳에서 관리 → 코드 중복 ⬇️
- **같은 내용**의 코드를 **하나 이상의 클래스에 중복적으로 추가**해야하는 경우 → **상속관계**를 이용해 코드의 중복 ⬇️

예시3

- Child 클래스를 상속받는 GrandChild 라는 새로운 클래스 추가.

```java
class Parent{}
class Child extends Parent {}
class Child2 extends Parent {}
class GrandChild extends Child {}
```

- 상속 계층도
    
    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/fdd5c604-bd83-4dc5-ae23-79313ce3527f/Untitled.png)
    
    - 자손 클래스는 조상 클래스의 모든 멤버를 물려받음 → GrandChild 클래스는 Child 클래스의 모든 멤버, Child 클래스의 조상인 Parent 클래스로부터 상속받은 멤버까지 상속.

예시4

- Parent 클래스에 정수형 변수 age를 멤버변수로 추가 → Parent 클래스는 클래스 Child, Child2, GrandChild의 조상이므로 Parent 클래스에 추가된 멤버변수 age → Parent 클래스의 모든 자손에 추가됨.
- 클래스간 상속관계 → 자손 클래스들의 공통적인 부분은 `조상클래스`에서 관리하고 자손 클래스는 자신에 정의된 멤버들만 관리 → 코드가 적어져 관리 easy.

전체 프로그램을 구성하는 클래스를 면밀히 설계 분석🧐 → 클래스 간 **상속관계를 적절히 맺어주는 것**이 객체지향 프로그래밍에서 가장 중요한 부분.

- **자손 클래스의 인스턴스를 생성**하면 조상 클래스의 멤버도 함께 생성 → 따로 조상 클래스의 인스턴스를 생성하지 않고도 조상 클래스의 멤버 사용 가능

## 1.2 클래스간의 관계 — 포함관계

클래스간의 포함관계 → 한 클래스의 멤버변수로 다른 클래스 타입의 참조변수를 선언하는 것을 뜻함.

원을 표현하기 위한 Circle 클래스

```java
class Circle{
	int x;
	int y;
	int r;
}
```

그리고 좌표상의 한 점을 다루기 위한 Point 클래스

```java
class Point{
	int x;
	int y;
}
```

이때 Point 클래스를 재사용해 Circle 클래스 작성

```java
class Circle{
	// int x; // 원점의 x좌표
	// int y; // 원점의 y좌표
	// ↓
	Point c = new Point(); // 원점
	int r;
}
```

하나의 거대한 클래스를 작성 → 단위별로 여러 개의 클래스 작성 → 클래스를 포함관계로 재사용 → 간결하고 손쉽게 클래스 작성 가능

## 1.3 클래스 간의 관계 결정하기

- 클래스 작성에 있어 상속? 포함? 관계를 결정하는 건 혼란스러움.
    - 앞서 Circle 클래스의 경우 Point 클래스를 **포함** 대신 **상속시키면**..
        
        ```java
        class Circle extends Point{ // 상속
        	// Point c = new Point();
        	int r;
        }
        ```
        
- `~은 ~이다(is -a)`와 `~은 ~을 가지고 있다(has -a)`를 넣어서 문장을 만들어보면 클래스 간의 관계가 보다 명확해짐.
    - `~은 ~이다(is -a)` : **상속관계**
    - `~은 ~을 가지고 있다(has -a)` : **포함관계**
- 원은 점이다. (Circle **is a** Point) ❌
- 원은 점을 가지고 있다. (Circle **has a** Point) ⭕️ → **포함관계**가 적절.

## 1.4 단일 상속(single inheritance)

- C++에서는 다중상속을 허용 but, 자바에서는 단일 상속만을 허용.
    - 다중상속
        - 장점: 여러 클래스 상속 가능 → 복합적인 기능 가진 클래스 작성 가능
        - 단점: 클래스 간 관계 매우 복잡, 서로 다른 클래스로부터 상속받은 멤버간 이름이 같은 경우 구별할 수 있는 방법이 없다는 단점.

## 1.5 Object 클래스 — 모든 클래스의 조상

- Object 클래스: 모든 클래스 상속계층도의 최상위에 있는 조상 클래스.
    - 자바의 모든 클래스는 Object 클래스의 멤버들을 상속 → Object 클래스에 정의된 멤버들 사용 가능.
    - toString(), equals(Object o)와 같은 메서드들을 따로 정의하지 않고도 사용할 수 있었던 이유 → Object클래스에 정의됨.

# 2. 오버라이딩(overriding)

## 2.1 오버라이딩이란?

- 조상 클래스로부터 상속받은 메서드의 내용 변경
- 상속받은 메서드를 그대로 사용하기도 하지만, 자손 클래스 자신에 맞게 변경해야 하는 경우 많음. → 조상의 메서드 **오버라이딩** 필요.

```java
// 2차원 좌표계 한 점 표현 Point 클래스
class Point{
	int x;
	int y;
	Stirng getLocation(){
		return "x: "+x+", y"+y;
	}
}
// 3차원 좌표계 한 점 표현 Point3D 클래스
	class Point3D extends Point{
		int z;
		String getLocation(){ // 오버라이딩
				return "x: "+x+" ,y: "+y+", z"+z;
		}
}
```

- Point3D클래스는 Point 클래스로부터 getLocation 상속 → 3차원 좌표계의 한점 표현 필요. → 메서드를 Point3D 클래스 자신에 맞게 z축 좌표값도 포함해 반환하도록 오버라이딩.
- **새로운 메서드를 제공하는 것보다, 오버라이딩하는 것**이 바른 선택임👍

## 2.2 오버라이딩의 조건

- 오버라이딩은 메서드의 내용만을 새로 작성 → 메서드의 선언부는 조상의 것과 완전히 일치해야!
- 오버라이딩 성립 조건
    - 자손 클래스에서 오버라이딩하는 메서드는 조상 클래스의 메서드와
        - 이름이 같아야 함
        - 매개변수가 같아야 함
        - 반환 타입이 같아야 함(JDK1.5부터 반환타입을 자손 클래스의 타입으로 변경하는 것은 가능하도록 조건 완화됨)

= 한마디로 **선언부가** 서로 일치해야!

다만, **접근 제어자**와 **예외**는 제한된 조건 하에서만 다르게 변경 가능.

1. **접근 제어자는 조상 클래스의 메서드보다 좁은 범위로 변경 불가.**
    - 만일 조상 클래스에 정의된 메서드의 접근 제어자 : `protected`  → 오버라이딩한 자손의 클래스 메서드는 접근 제어자가 `protected` or `public` 이어야 함.
    - 접근범위 넓은 ->좁은 것 순으로 나열
        - public → protected → default → private
2. **조상 클래스의 메서드보다 많은 수의 예외 선언 불가.**
    - `Exception`은 모든 예외의  최고 조상 → 가장 많은 예외를 던질 수 있으므로 주의!
    

> 조상 클래스의 메서드를 자손 클래스에서 오버라이딩
> 
1. **접근 제어자를 조상 클래스의 메서드보다 좁은 범위로 변경 불가.**
2. **예외는 조상 클래스의 메서드보다 많인 선언 불가**
3. **인스턴스 메서드를 static 메서드로 또는 반대로 변경 불가**

## 2.3 오버로딩 vs 오버라이딩

- 오버로딩: 기존에 없는  새로운 메서드 정의(new!)
- 오버라이딩: 상속받은 메서드의 내용을 변경하는 것(change, modify)

## 2.4 super

- super는 자손 클래스에서 조상 클래스로부터 상속받은 멤버를 참조하는 데 사용되는 참조 변수.
- 멤버변수와 지역변수의 이름이 같을 때 this를 붙여 구별했듯이 상속받은 멤버와 자신의 멤버와 이름이 같을 때는 super을 붙여 구별.
    - 조상 클래스로부터 상속받은 멤버도 자손 클래스 자신의 멤버이므로, super대신 this 사용 가능
    - but 조상 클래스의 멤버와 자손클래스의 멤버가 중복 정의되어 서로 구별 ⇒ super 사용 👍
- 조상의 멤버와 자신의 멤버를 구별하는 데 사용된다는 점 제외 → super와 this는 근본적으로 같음.
- static 메서드(클래스 메서드)는 인스턴스와 관련 ❌
- this 와 마찬가지로 super 역시 static 메서드에서 사용 불가.
    - 인스턴스 메서드에서만 사용 가능.

## 2.5 super()— 조상 클래스의 생성자

- this()와 마찬가지로 super() 역시 생성자임.
- this()는 같은 클래스의 다른 생성자 호출
- super)은 조상클래스의 생성자 호출
- 자손 클래스의 인스턴스 생성 → 자손 멤버와 조상 멤버가 모두 합쳐진 하나의 인스턴스 생성
    - 자손 클래스의 인스턴스가 조상 클래스 멤버 사용 가능.
    - 이때 조상 클래스 멤버의 초기화 작업이 수행되어야 하기 때문에 자손 클래스의 생성자에서 조상 클래스의 생성자가 호출 되어야 함.
    - 조상 클래스 생성자 호출 → 클래스 상속관계를 거슬러 올라가면서 계속 반복 → 모든 클래스의 최고 조상인 Object 클래스의  생성자인 Object()까지 가야 끝.
- 따라서 Object 클래스를 제외한 모든 클래스의 생성자는 첫 줄에 반드시 자신의 다른 생성자 또는 조상 생성자 호출.
- 그렇지 않으면 컴파일러는 생성자의 첫 줄에 super(); 자동적 추가.

인스턴스 생성시 클래스를 선택하는 것만큼 **생성자 선택**도 중요함.

1. 클래스 — 어떤 클래스의 인스턴스 생성?
2. 생성자 — 선택한 클래스의 어떤 생성자를 이용해서 인스턴스 생성?

**조상 클래스의 멤버변수는 이처럼 조상의 생성자에 의해 초기화되도록 해야 함.**

## 3. package와 import

## 3.1 패키지(package)

- 패키지: 클래스의 묶음
    - 패키지에는 클래스 or 인터페이스 포함 가능
    - 서로 관련된 클래스끼리 그룹 단위로 묶어 놓음 → 클래스 효율적 관리 가능
    - 같은 이름의 클래스 일지라도 서로 다른 패키지 존재 가능 → 자신만의 패키지 체계 유지 → 다른 개발자가 개발한 클래스 라이브러리의 클래스 이름이 충돌하는 것을 피할 수 있음.
- 지금까지는 단순히, 클래스 이름만으로 클래스 구분 → 사실 클래스의 실제 이름(full name)은 패키지명 포함한 것.
    - e.g. String 클래스의 실제 이름: java.lang.String 임.
    - java.lang 패키지에 속한 String 클래스라는 의미.
    - 같은 이름의 클래스일지라도 서로 다른 패키지에 속하면 패키지명으로 구별 가능.
- **클래스가 물리적으로 하나의 클래스 파일(.class)인 것과 같이 패키지는 물리적으로 하나의 디렉토리.**
    - 어떤 패키지에 속한 클래스 : 해당 디렉토리에 존재하는 클래스 파일이어야.
    - e.g.) java.lang.String 클래스 ⇒ 물리적으로 디렉토리 java의 서브디렉토리인 lang에속한 String.class 파일임.
    - 우리가 자주 사용하는 System 클래스 역시 java.lang 패키지에 속함 → lang 디렉토리에 포함되어있음.
        - String 클래스는 rt.jar 파일에 압축되어있음 → 이 파일의 압축을 풀면 클래스 파일이 보임.
        - 클래스 파일들을 압축 한 것 : jar 파일(*.jar)

## 3.2 패키지의 선언

- 클래스나 인터페이스의 소스파일(.java)의 **맨 위에 한줄만** 적어주면 됨.
    - `package 패키지명;`
- 모든 클래스는 반드시 하나의 패키지에 포함되어야 함.
    - 그럼에도 불구하고, 지금까지 소스파일 작성 시 패키지를 선언하지 않고도 아무런 문제가 없었던 이유: 자바에서 기본적으로 제공하는 이름없는 패키지(unnamed package)때문임.
    - 소스파일에서 자신이 속할 패키지를 지정 x → 자동적으로 이름 없는 패키지에 속함.

## 3.3 import 문

- 소스코드 작성 시 다른 패키지 클래스 사용 → **패키지명이 포함된 클래스 이름**을 사용해야.
    - 매번 패키지명을 붙이긴 불편함.
- 클래스 코드 작성 전에 **import 문으로 사용하고자 하는 클래스의 패키지를 미리 명**시 → 소스코드에 사용되는 클래스 이름에서 패키지명 **생략 가능**

## 3.4 import 문의 선언

- 모든  소스파일(.java)에서 import 문은 package 문 다음에, 그리고 클래스 선언문 이전에 위치 해야.
- import 문은 package문과 달리 한 소스파일에 여러번 선언 가능.

```java
// import 문 선언
import 패키지명.클래스명;
	// 또는
import 패키지명.*;
```

- 패지키명.* → 지정된 패키지에 속하는 모든 클래스를 패키지 없이 사용 가능.
- 두 코드는 실행 시 성능상의 차이는 전혀 없음

## 3.5 static import 문

- import 문 → 클래스의 패키지명을 생략할 수 있는 것과 같이
- **static import 문 → static 멤버를 호출할 때 클래스 이름 생략 가능**.
    - 특정 클래스의 static 멤버를 자주 사용할 때 편리.

```java
// 코드 간결해지는 static import문
import static java.lang.Integer.*;
import static java.lang.Math.random; // out.println(random()); 으로 간략히 가능
import static java.lang.System.out;
```