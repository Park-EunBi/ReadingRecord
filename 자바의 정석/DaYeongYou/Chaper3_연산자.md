# 1. 연산자

- 프로그래밍 언어에서 가장 기본적이면서도 중요한 요소
- 각 연산자의 특징과 수행결과, 그리고 우선순위에 대해 잘 알아야 함
- 실제 프로그래밍에서 사용되는 대부분의 수식은 상식적으로 우선순위 파악 가능
- 연산순서가 확실하지 않다면 괄호() 를 사용해서 묶어줌

## 연산자 종류
![image](https://user-images.githubusercontent.com/71822139/212336473-05901b80-0a59-454a-b309-bf722e008606.png)
## 연산자 우선순위
- 하나의 식에 연산자가 둘 이상 있을 때, 어떤 연산을 먼저 수행할 지 자동 결정
![image](https://user-images.githubusercontent.com/71822139/212337021-5f52b14c-c5b8-4330-be8d-b6288cdf91f7.png)
## 연산자 결합규칙
- 우선순위가 같은 연산자 있을 때, 어떤 연산자를 먼저 수행?
![image](https://user-images.githubusercontent.com/71822139/212336819-303a7388-d478-4a56-8b5d-60f9f17c6678.png)

### 연산자 우선순위, 결합법칙 정리

1. 산술 > 비교 > 논리 > 대입. 대입은 가장 마지막에 수행
2. 단항(1) > 이항(2) > 삼항(3). 단항 연산자의 우선순위가 이항 연산자보다 높음
3. 단항 연산자와 대입 연산자를 제외한 모든 연산의 진행방향은 왼쪽에서 오른쪽

# 2. 단항 연산자

## 2.1 증감 연산자 ++, - -

- 일반적으로 단항 연산자는 피연산자의 왼쪽에 위치
- but 증가 연산자 `++` 와 감소 연산자 `--` 는 양쪽 모두 가능
- 어느 위치에 있느냐에 따라 연산 결과 달라짐
- boolean 형을 제외한 모든 기본형(primitive type) 변수에 사용 가능
- 피연산자의 왼쪽에 사용하는 `전위형` , 오른쪽에 사용하는 `후위형` 존재

```java
public class OperatorEx1 {
    public static void main(String args[]) {
        int i = 5;
        i++;
        System.out.println(i);
        i = 5;
        ++i;
        System.out.println(i);
    }
}
```

- i의 값을 증가시킨 후 출력 → 6 출력됨
- 어떤 수식에 포함 x, 단독 사용 → 차이x
- 다른 수식에 포함되거나 함수의 매개변수로 사용될 경우 전위형과 후위형 결과 다름
- e.g) 다른 수식에 포함된 예제
    
    ```java
    public class OperatorEx2 {
        public static void main(String args[]) {
            int i = 5;
            int j = 0;
            j = i++;
            System.out.println("j=i++; 실행 후, i=" + i + ", j=" + j);
    				// j=i++; 실행 후, i=6, j=5
            i = 5;
            j = 0;
            j = ++i;
            System.out.println("j=++i; 실행 후, i=" + i + ", j=" + j);
    				// j=++i; 실행 후, i=6, j=6
        } 
    }
    ```
    
    - 수식을 계산하기 위해 수식에 포함된 변수의 값을 읽어와야 함.
    - 전위형은 변수의 값을 먼저 증가시킨 후 변수의 값 읽어옴
    - 후위형은 변수의 값을 먼저 읽어온 후 값 증가시킴
- e.g) 함수의 매개변수에 사용된 예
    
    ```java
    public class OperatorEx3 {
        public static void main(String args[]) {
            int i = 5, j = 5;
            System.out.println(i++); // 5
            System.out.println(j++); // 5
            System.out.println("i= " + i + ", j= " + j); // i= 6, j= 6
        }
    }
    ```
    
    - i는 값이 증가되기 전에 참조→ println() 메서드에 i에 저장된 값 5를 넘겨주고 나서 i의 값 증가, 5 출력
    - j는 j에 저장된 값을 증가 시킨 후 println()에 값을 넘겨줌, 6 출력
- 감소 연산자는 피연산자의 값을 1 감소시킨다는 것을 제외하고 동일

## 2.2 부호 연산자 +, -

- 피 연산자의 부호 변경
- boolean 형과 char형을 제외한 나머지 기본형에 사용
- +: 피연산자에 양수 1을 곱한값
- -: 피연산자에 음수 1을 곱한값

## 2.3 비트전환 연산자 ~

- 정수형, char형에서만 사용 가능
- 피연산자를 2진수로 표현 → 0은 1로 1은 0으로 변경
- 연산자 `~` 에 의해 비트전환 시 부호가 반대로 변경

## 2.4 논리부정 연산자 !

- boolean형에만 사용 가능
- true→false
- false→true로 변경
- e.g) 한번 누르면 켜지고, 다시 한번 누르면 꺼지는 tv의 전원버튼과 같은 토글버튼 구현한 예제
    
    ```java
    public class OperatorEx7 {
        public static void main(String[] args) {
            boolean power = false;
            System.out.println(power);
            power = !power;
            System.out.println(power);
            power = !power;
            System.out.println(power);
        }
    }
    ```

# 3. 산술 연산자

- 사칙 연산자, 나머지 연산자, 쉬프트 연산자 모두 두개의 피연산자를 취하는 이항 연산자
- 이항 연산자는 피연산자의 크기가 int(4byte)보다 작으면 int(4byte)로 변환한 다음 연산 수행
- 연산 수행 전 피연산자들의 타입 일치시킴(==산술 변환)
  - 두 피연산자의 타입을 일치시킬 때, 두개 중 더 큰 타입으로 일치시킴.
    ```
    long + int -> long + long -> long
    float + int -> float + float -> float
    double + float -> double + double -> double
    ```
## 3.1 사칙 연산자 +, -, *, /

- 곱셈(*), 나눗셈(/), 나머지(%) 연산자가 덧셈(+), 뺄셈(-) 연산자보다 우선순위 높음
- 피 연산자가 정수형인 경우 나누는 수를 0을 사용할 수 없음
    - 만일 0으로 나누면 컴파일은 되지만, 런타임오류(ArithmeticException) 발생
- 부동소수점값인 0.0f, 0.0d로 나누는 것은 가능하지만 그 결과는 NaN

## 3.2 나머지 연산자 %

- 왼쪽의 피연산자를 오른쪽 피연산자로 나누고 난 나머지 값 돌려주는 연산자
- boolean 형을 제외하고 모든 기본형 변수에 사용 가능
- 주로 짝수, 홀수 또는 배수 검사 등에 사용 됨
- e.g) 3의 배수 출력하는 예제
    
    ```java
    public class Operator20 {
        public static void main(String args[]) {
            // i가 1부터 10이 될 때까지, {} 안의 문장 반복 수행
            for (int i = 1; i <= 10; i++) {
                if (i % 3 == 0) {
                    System.out.println(i);
                }
            }
        }
    }
    ```
    

## 3.3 쉬프트 연산자 <<, >>, >>>

- 정수형 변수에만 사용 가능
- 피연산자의 각 자리(2진수로 표현했을 때) 오른쪽 혹은 왼쪽으로 이동(shift)한다고 해서 쉬프트 연산자임
- 오른쪽으로 n자리 이동 → 피연산자를 2^n 으로 나눈 것과 같은 결과
- 왼쪽으로 n자리 이동 → 피연산자를 2^n으로 곱한 것과 같은 결과
1. << 연산자
    
    피 연산자의 부호와 상관없이 자리를 왼쪽으로 이동시키며 빈칸을 0으로 채우면 된다.
    
2. >> 연산자
    
    음수인 경우 부호를 유지시켜주기 위해 빈자리를 1로 채우게 됨
    
3. >>> 연산자
    
    부호에 상관없이 항상 0으로 빈자리를 채움
    

# 4. 비교 연산자

- 두개의 변수 또는 리터럴을 비교하는데 사용되는 연산자
- 주로 조건문, 반복문의 조건식에 사용됨
- 연산결과는 true 또는 false
- 이항연산자이므로, 비교하는 피연산자의 자료형이 서로 다를 경우 자료형의 범위가 큰 쪽으로 형 변환되어 피연산자의 타입을 일치시킨 후 비교

> 자동 형변환(Promotion)
- 컴파일러가 자동으로 형변환을 해주는 것
- 리터럴(상수, 변하지 않는 값)보다 변수의 타입이 범위가 넓을 경우 이뤄짐.
  - 리터럴의 타입이 범위가 더 넓을 경우 Error 발생
    -> 직접 형 변환 필요.
```
float f = 1234; // int 타입의 값을 float타입의 변수에 저장
float f = (float)1234; // 컴파일러가 자동으로 형변환을 해줌

int i = 3.14f; // Error 발생(int < float)
int i = (int)3.14f; // OK 'i = 3' 으로 저장 
```
![image](https://user-images.githubusercontent.com/71822139/212339442-a2b045e7-d6d9-4c5c-bce6-b8dd20f62365.png)


## 4.1 대소비교 연산자 < , >, ≤, ≥

- 두 피연산자의 크기를 비교하는 연산자
- 기본형 중에서는 boolean형을 제외한 나머지 자료형에 사용 가능
- 참조형에는 사용 불가

## 4.2 등가비교 연산자 ==, ≠

- 두 피연산자에 저장되어 있는 값이 같은지 또는 다른지 비교하는 연산자
- 대소비교 연산자와는 달리 기본형은 물론 참조형에도 사용 가능
    - 기본형: 변수에 저장된 값 등가비교
    - 참조형: 두 개의 피연산자가 같은 객체를 가리키고 있는지 비교

```java
public class OperatorEx24 {
    public static void main(String[] args) {
        float f = 0.1f;
        double d = 0.1;
        double d2 = (double) f;

        System.out.println("10.0==10.f?" + (10.0 == 10.0f)); // true
        System.out.println("0.1==0.1f?" + (0.1 == 0.1f)); // false
        System.out.println("f=" + f);
        System.out.println("d=" + d);
        System.out.println("d2" + d2);
        System.out.println("d==f ?" + (d == f)); // false
        System.out.println("d==d2 ?" + (d == d2)); // false
        System.out.println("d2==f ?" + (d2 == f)); // true
    }
}
```

- 10.0==10.0f는 true이지만 0.1==0.1f는 false이다.
    - 왜?
    - 정수형과 달리 실수형인 float와 double의 값은 근사값으로 저장되기 때문임.
    - 10.0f를 double으로 형변환하면 10.0을 얻지만, 0.1f를 double로 형변환하면 0.1이 아닌 0.10000000149011612를 얻음.
    - 0.1에 상당히 가깝지만 정확히 0.1은 아님
    - 산술계산에서 무시할 수 있을 정도의 작은 오차지만 값의 크기와 같고 다름을 판단하는 비교연산에서 문제가 됨.
    - 이 문제를 해결하기 위해서는 형변환을 통해 두 피연산자의 타입을 float로 맞춰서 비교연산과정에서 자동형변환이 일어나지 않게 하거나 소수점 몇 째 자리까지 동일하게 잘라서 비교 해야 함.

# 5. 논리 연산자

## 5.1 논리 연산자 &&, ||

- && 가 || 보다 우선순위가 높기 때문에 괄호를 사용해 우선순위를 명확히 해줄 것
- 효율적인 연산 가능
    - or 연산 : 두 개의 피연산자 중 어느 한 쪽만 true 이어도 전체 연산 결과는 true
        - 좌측의 피연산자가 true이면, 우측의 피연산자의 값은 검사 x
    - and 연산 : 어느 한쪽만 false여도 전체 연산결과가 false이므로
        - 좌측의 피연산자가 false이면, 우측의 피연산자의 값은 검사 x
        - 따라서 false일 확률이 높은 피연산자를 연산자의 좌측에 놓아야 더 빠른 연산가능
    
    → 같은 조건식이라도 피연산자의 위치에 따라 연산속도 달라질 수 있음
    

## 5.2 비트 연산자 &, |, ^

- 비트 연산자는 이진 비트연산 수행
- 값을 이진수로 표현했을 때 각 자리수를 아래 규칙에 따라 연산 수행
- 실수형인 float와 double을 제외한 모든 기본형에 사용가능

| |(or 연산자) | 피연산자 중 한쪽의 값이 1이면 1을 결과로 얻음. 그 외에는 0을 얻음 |
| --- | --- |
| &(and 연산자) | 피연산자 양쪽이 모두 1이어야 1을 결과로 얻음. 그 외에는 0을 얻음 |
| ^(xor 연산자) | 피연산자의 값이 서로 다를 때만 1을 결과로 얻음. 같을 때는 0을 얻음 |

# 6.  그 외의 연산자

## 6.1 삼항 연산자 ? :

- 세개의 피연산자를 필요로 함
- if문으로 변경 가능

형태) (조건식) ? 식1: 식2

조건식의 연산결과가 true이면 식1, false이면 식2를 결과로 얻음

## 6.2 대입 연산자 =, op=

- 변수에 값 또는 수식의 연산결과를 저장하는데 사용
- 대입 연산자의 왼쪽에는 반드시 변수가 위치해야 함
- 오른쪽에는 리터럴, 변수, 수식 위치
- 모든 연사자 중 가장 낮은 우선순위 → 제일 마지막에 수행
- 대입 연산자는 다른 연산자와 결합해 **복합대입연산자**인 `op=` 와 같은 방식으로 사용 가능
    - e.g) `i = i + 3` == `i += 3`
