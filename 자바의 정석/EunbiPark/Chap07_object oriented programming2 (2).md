# 다형성 (polymorphism)

## 다형성이란

여러 가지 형태를 가질 수 있는 능력 

한 타입의 참조변수로 여러 타입의 객체를 참조할 수 있도록하여 다형성 구현 

⇒ 조상 클래스 타입의 참조변수로 자손클래스의 인스턴스 참조

인스턴스 타입과 참조변수의 타입이 일치하도록 사용하는 것이 보통의 경우 

그러나 상속 관계일 경우 조상클래스 타입의 참조변수로 자손클래스의 인스턴스를 참조하는 것이 가능하다 

```java
Tv t = new CaptionTv();
```

이 경우에는 CaptionTv 인스턴스 멤버 중에서 Tv 클래스에 정의된 멤버만 사용 가능하다 (조상 클래스에 정의된 멤버만 사용가능하다)

⇒ 참조 변수의 타입에 따라 사용할 수 있는 멤버의 개수가 달라진다 

```java
CaptionTv c = new Tv(); // 자손 타입 참조변수로 조상 타입의 인스턴스를 참조하는 것은 불가 
```

위의 경우 실제 생성된 Tv인스턴스보다 참조변수 c가 사용할 수 있는 멤버 개수가 더 많기에 사용이 불가능하다 

**********************************************************************************************************************************************************************************************************************************참조변수가 사용할 수 이쓴 멤버의 개수는 인스턴스의 멤버 개수보다 같거나 적어야 한다********************************************************************************************************************************************************************************************************************************** 

클래스는 상속을 통해 확장이 가능하지만 축소는 불가능하다 

그렇기에 조상 인스턴스의 멤버 갯는 자손 인스턴스의 멤버 개수보다 항상 적거나 같다 

<aside>
💡 조상 타입의 참조변수로 자손 타입의 인스턴스를 참조할 수 있다 
반대로 자손타입의 참조 변수로 조상 타입의 인스턴스를 참조할 수없다

</aside>

## 참조변수의 형변환

상속 관계에 있는 클래스 사이에서는 참조변수도 형 변환이 가능하다 

자손 타입 ↔ 조상 타입 

자손타입의 참조변수를 조상타입으로 형변환하는 경우에는 형변환을 생략할 수 있다 (업캐스팅)

| 업캐스팅 | 자손 → 조상  | 형변환 생략 가능  |
| --- | --- | --- |
| 다운캐스팅 | 조상 → 자손  | 형변환 생략 불가  |

```java
Car car = null;
FireEngine fe = enw FireEngine();
FireEngine fe2 = null;

car = fe; // 업캐스팅 - 형변환 생략 가능 
fe2 = (FireEngine) car; // 다운 캐스팅 - 형변환 생략 불가 
```

형변환은 참조변수의 타입을 변환하는 것이지 인스턴스를 변환하는 것이 아니다 그러므로 참조변수의 형변환은 인스턴스에 아무런 영향을 미치지 않는다 

참조변수의 형변환을 통해 참조하고 있는 인스턴스에서 사용할 수 있는 멤버의 범위 (개수)를 조절하는 것이다

## instanceof 연산자

참조변수가 참조하고 있는 인스턴스의 실제 타입을 알아보기 위해 instanceof 연산자 사용 

주로 조건문에 사용, 연산의 결과가 true가 나왔다면 해당 타입으로 형 변환이 가능하다는 말 

```java
참조변수 instanceof 타입(클래스명)
```

```java
void doWork(Car c) {
	if (c instanceof FireEngine) {
		FireEngine fe = (FireEngine) c;
		fe.water();
	} else if (c instanceof Ambulance) {
		Ambulance a = (Ambulance) c;
		a.siren();
}
```

<aside>
💡 어떤 타입에 대한 instanceof 연산의 결과가 true라는 것은 검사한 타입으로 형변환이 가능하다는 것을 뜻한다

</aside>

## 참조변수와 인스턴스의 연결

멤버변수가 조상 클래스와 자손 클래스에 중복으로 정의된 경우, 조상 타입의 참조변수를 사용했을 때는 조상 클래스에 선언딘 멤버변수가 사용되고, 자손 타입의 참조변수를 사용했을 때는 자손 클래스에 선언된 멤버변수가 사용된다 

메서드는 참조변수의 타입에 관계없이 항상 실제 인스턴스의 타입에 정의된 메서드가 호출된다 

⇒ 인스턴스변수에 직접 접근하면 참조변수의 타입에 따라 사용되는 인스턴스 변수가 달라질 수 있으므로 주의해야 한다 

## 매개변수의 다형성

매개변수에 조상 클래스를 받으면 다형성을 구현할 수 있다 

## 여러 종류의 객체를 배열로 다루기

조상타입의 참조변수 배열을 사용하면 공통의 조상을 가진 서로 다른 종류의 객체를 배열로 묶어 다룰 수 있다 

```java
Product p[] = new Product[3];
p[0] = new Tv();
p[1] = new Computer();
p[2] = new Audio();
```

Vector 클래스를 사용하여 동적으로 할당되는 배열을 만들 수 있다 

# 추상클래스(abstract class)

## 추상클래스란?

미완성 메서드를 포함하는 미완성 설계도 

추상 클래스로는 인스턴스를 생성할 수 없으며, 상속을 통해서 자손클래스에서만 완성될 수 있다 

```java
abstract class 클래스이름 {
	...
}
```

추상 메서드를 포함하고 있다는 것을 제외하고 일반 클래스와 동일하다 

생성자, 멤버변수, 메서드 모두 가능하다 

## 추상 메서드

선언부만 작성하고, 구현부를 작성하지 않은 메서드 

메서드의 내용이 상속 받는 클래스에 따라 달라질 수 있기 때문에 선언부만 작성하는 것 

```java
abstract 리턴타입 메서드이름();
```

추상클래스로부터 상속받는 자손클래스는 오버라이딩을 통해 추상 메서드를 모두 구현해야 한다 

상속받은 메서드 중 하나라도 구현하지 않는다면 자손 클래스 또한 추상 클래스로 지정해야 한다 

```java
// 추상 클래스 
abstract class Player {
	abstract void play (int pos); // 추상 메서드 
	abstract void stop();
}

class AudioPlayer extends Player {
	void play (int pos) {) // 추상메서드 구현 
	void stop() {}
}

abstract class AbstractPlayer extends Player {
	void play (int pos) {}
}

```

## 추상클래스의 작성

| 상속 | 자손 클래스를 만드는 데 조상 클래스를 사용하는 것 |
| --- | --- |
| 추상화 | 클래스간의 공통점을 찾아내서 공통의 조상을 만드는 작업 |
| 구체화 | 상속을 통해 클래스를 구현, 확장하는 작업  |

```java
abstract class Player {
 // 추상 클래스
}

class CDPlayer extends Player {
	// 추상클래스 상속 받아 내용 구현 
}
```

자손 클래스에서 오버라이딩 하여 구현하는 것과 추상 클래스를 활용하는 것의 차이는 

추상 클래스를 사용하면 자손 클래스에서 **반드시 추상 메서드를 구현**해야 한다는 것이다 

추상 클래스를 활용하여 다형성을 구현하면 

서로 다른 종류의 인스턴스를 하나의 묶음으로 다룰 수도 있다

```java
Unit[] group = new Unit[4];

group[0] = new Marine();
group[1] = new Tank();
group[2] = new Marine();
```

조상 클래스타입의 참조변수로 자손 클래스의 인스턴스를 참조하는 것이 가능하기에 조상 클래스타입의 배열에 자손 클래스의 인스턴스를 담을 수 있다 

→ 공통 조상이 있기에 가능한 것 

# 인터페이스 (interface)

## 인터페이스란?

일종의 추상 클래스 

추상 클래스처럼 추상 메서드를 갖지만 추상클래스보다 추상화 정도가 높아 몸통을 갖춘 일반 메서드와 멤버변수를 구성원으로 가질 수 없다 

오직 추상메서드와 상수만을 멤버로 가질 수 있다 

| 추상 클래스  | 인터페이스 |
| --- | --- |
| 미완성 설계도  | 기본 설계도 |

## 인터페이스의 작성

```java
interface 인터페이스 이름 {
	public static final 타입 상수이름 = 값;
	public abstract 메서드이름 (매개변수목록);
}
```

### 인터페이스 멤버들의 제약사항

- 모든 멤버변수는 pualic static final이어야 하며, 생략 가능
- 모든 메서드는 puvlis abstract 이어야 하며, 생략 가능
    
    단 static 메서드와 디폴트 메서드는 예외 
    

## 인터페이스의 상속

인터페이스는 인터페이스로만 상속 받을 수 있다

다중 상속 가능 

```java
interface Fightable extends Movable, Attackable {}
```

## 인터페이스의 구현

인터페이스 자체로는 인스턴스를 생성할 수 없다 

인터페이스에 정의된 추상메서드의 몸통을 만들어주는 클래스를 작성해야 한다 

```java
class 클래스이름 implements 인터페이스이름 { // 해당 클래스는 인터페이스를 구현한다 라고 함
	// 추상 메서드 구현
}
```

구현하려는 인터페이스의 메서드의 일부만 구현한다면 abstract를 붙여 추상 클래스로 선언해야 한다 

```java
// 상속과 구현을 동시에 할 수 있다 
class Fighter extends Unit implement Fightable {
	public void move (int x, int y) {} // 구현
	public void attack(Unit u) {} // 상속
}
```

인터페이스 이름은 보통 able으로 끝남 (필수는 아님)

어떠한 기능, 행위를 하는데 필요한 메서드를 제공한다는 의미를 강조하기 위해 그럼

인터페이스의 메서드는 public abstract 로 선언되기에 이를 구현하기 위해서는 접근 제어자를 반드시 public 으로 해야 한다 

(오버라이딩 할 때는 조상의 메서드보다 넓은 범위의 접근 제어자를 지정해야 하기에)

## 인터페이스를 이용한 다중 상속

인터페이스는 static 상수만 정의할 수 있기에 조상클래스의 멤버변수와 충돌하는 경우는 거의 없다

충돌 된다고 하더라도 클래스 이름을 붙여 구분이 가능하다 

또한 추상 메서드는 구현 내용이 전혀 없으므로 조사 클래스의 메서드와 선언부가 일치하는 경우에는 조상 클래스 쪽의 메서드를 상속 받으면 되므로 문제가 되지 않는다 

그러나 이렇게 된다면 상속 받는 멤버의 충돌은 피할 수 있지만 

다중 상속의 단점을 잃게 된다 (자바는 클래스 다중상속을 지원하지 않지만 인터페이스는 다중 상속을 지원한다)

만약 두 개의 클래스로부터 상속을 받아야 한다면

두 조상 클래스 중 비중이 높을 족을 선택하고 

다른 한 쪽은 클래스 내부에 멤버로 포함시키거나 필요한 부분을 뽑아 인터페이스로 만든 다음 구현하면 된다 

인터페이스를 새로 작성하지 않고도 클래스에 포함시키는 것만으로도 충분하지만 

인터페이스를 이용하면 다형적 특성을 이용할 수 있다는 장점이 있다 

## 인터페이스를 이용한 다형성

인터페이스는 이를 구현한 클래스의 조상이라고 할 수 있다 

그러므로 해당 인터페이스 타입의 참조변수로 이를 구현한 클래스의 인스턴스를 참조할 수 있으며, 형변환도 가능하다 

```jsx
Fightable f (fightable)new Fighter();

Fighterable f = new Fighter();
```

인터페이스는 메서드의 매개변수 타입으로 사용될 수 있다 

→ 메서드 호출 시 해당 인터페이스를 구현한 클래스의 인스턴스를 매개변수로 제공

메서드의 리턴 타입으로 인터페이스의 타입을 지정하는 것 또한 가능하다 

→ 메서드가 해당 인터페이스를 구현한 클래스의 인스턴스를 반환

```java
interface Parseable {
	public abstract void parse (String fileName);
}

class ParserManager {
	public static Parseable getParser (String type) { // 반환값이 인터페이스 
		if(type.equals("XML")) {
			return new XMLParser();
	} else {
		Parseable p = new HTMLParser();
		return p; // 인터페이스를 구현한 클래스의 인스턴스를 반환 
		// return new HTMLParser();
		}
	}
}

class XMLParser implements Parseable {
	public void parse(String fileName) {
		System.out.println(fileName + "-XML parsing completed.");
	}
}

class HTMLParser implements Parseable {
	public void parse (String fileName) {
		System.out.println(fileName + "-HTML parsing completed".);
	}
}

public static void main (Stirng args[]) {
	Parseable parser = ParserManager.getParser("XML");
...
}
```

## 인터페이스의 장점

- 개발 시간 단축
- 표준화 가능
- 관련없는 클래스간의 관계 형성
- 독립적인 프로그래밍 가능

조상이 다른 클래스에 같은 기능을 추가하고 싶을 때 

일부 자손 클래스에만 해당 내용을 추가하고 싶을 때 

인터페이스를 활용할 수 있다 

## 인터페이스의 이해

- 클래스를 사용하는 쪽과 클래스를 제공하는 쪽이 있다
- 메서드를 사용(호출)하는 쪽에서는 사용하려는 메서드의 선언부만 알면 된다

---

클래스 A는 클래스 B의 인스턴스를 생성하고 메서드를 호출하고 

둘은 직접적인 연관이 있다 

이 경우 클래스 A를 작성하려면 B가 작성 되어 있어야 한다 

또한 클래스 B의 메서드의 선언부가 변경되면 A 또한 변경되어야 한다 

⇒ 직접적인 관계의 클래스는 한쪽이 변경되면 다른 한 쪽이 변경되어야 한다 

---

그러나 클래스 A가 클래스 B를 직접 호출하지 않고 인터페이스를 매개체로 하여 클래스 A가 인터페이스를 통해 클래스 B의 메서드에 접근하도록 하면 클래스 B에 변경사항이 생겨도 클래스 A는 전혀 영향을 받지 않는다 

⇒ 두 클래스의 관계를 간접적으로 변경하기 위해서는 인터페이스를 이용하여 클래스 B의 선언과 구현을 분리해야 한다 

---

class B는 interface I를 구현한다 

class A는 interface I를 사용하여 작성한다 

⇒ 클래스 A를 사용하는데 클래스 B가 사용되지 않는다 

클래스 A는 여전히 클래스 B의 메서드를 호출하지만 인터페이스 I와 직접적인 관계에 있기에 B의 영향을 받지 않는다 

## 디폴트 메서드와 static 메서드

### 디폴트 메서드

추상 메서드의 기본적인 구현을 제공하는 메서드 

추상 메서드가 아니기에 디폴트 메서드가 새로 추가되어도 해당 인터페이스를 구현한 클래스를 변경하지 않아도 된다 

```java
interface MyInterface {
	void method();
	default void netMethod(){}
}
```

`newMethod();` 라는 추상 메서드를 추가하는 대신 디폴트 메서드를 추가하면 기존의 MyInterface를 구현한 클래스를 변경하지 않아도 된다 

→ 조상 클래스에 새로운 메서드를 추가한 것과 동일 

[기존 메서드와 이름 중복될 경우 해결하는 방법]

1. 여러 인터페이스의 디폴트 메서드 간의 충돌 
    - 인터페이스를 구현한 클래스에서 디폴트 메서드를 오버라이딩 해야 한다
2. 디폰트 메서드와 조상 클래스의 메서드 간의 충돌 
    - 조상 클래스의 메서드가 상속되고, 디폴트 메서드는 무시된다

# 내부 클래스 (inner class)

클래스 내부에 선언된다는 점을 제외하고는 일반적인 클래스와 동일하다 

## 내부 클래스란?

클래스 내에 선언된 클래스 

두 클래스가 긴밀한 관계일 때 사용 (실제로는 잘 사용되지 않음)

<aside>
💡 [내부 클래스의 장점]
- 내부 클래스에서 외부 클래스의 멤버들을 쉽게 접근 할 수 있다 
- 코드의 복잡성을 줄일 수 있다 (캡슐화)

</aside>

## 내부 클래스의 선언

```java
class Outer {
	class InstanceInner {}
	static class StaticInner {}

	void myMethod() {
		class LocalInner {}
	}
}
```

## 내부 클래스의 제어자와 접근성

내부 클래스는 외부 클래스의 멤버와 같이 간주되고 

인스턴스 멤버와 static 멤버 간의 규칙이 내부 클래스에도 똑같이 적용된다 

## 익명 클래스

클래스의 선언과 객체 생성을 동시에 하기에 

단 한번만 사용될 수 있고 오직 하나의 객체만을 생성할 수 있다 

```java
new 조상클래스이름() {
	// 멤버 선언 
}

new 구현인터페이스이름() {
	// 멤버 선언
}
```

이름이 없기에 생성자를 가질 수 없으며 

조상클래스의 이름이나 구현하고자 하는 인터페이스의 이름을 사용해서 정의하기에 하나의 클래스로 상속받는 동시에 인터페에스를 구현하거나 둘 이상의 인터페이스를 구현할 수 없다 

단 하나의 클래스를 상속받거나 단 하나의 인터페이스만을 구현할 수 있다 

```java
class InnerEx6 {
	 Object iv = new Object () {void method () {} };
	static Object cv = new Object () {void method() {} };

	void myMehtod() {
		Object lv = new Object () {void method () {} };
	}
} 
```
